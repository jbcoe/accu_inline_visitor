\documentclass[10pt,a4paper,twocolumn]{article}

% Use packages
\usepackage{newcent}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mathrsfs}
\usepackage{color}

% Set lengths
\setlength{\parindent}{0pt}
\setlength{\parskip}{10pt}
\addtolength{\columnsep}{0.05in}
\addtolength{\textwidth}{1in}
\addtolength{\oddsidemargin}{-0.5in}
\addtolength{\topmargin}{-1in}
\addtolength{\textheight}{1.5in}

% Little hypenation, left aligned
\hyphenpenalty=10000
%\raggedright

\makeatother

\renewcommand\section[1]{
    \begin{minipage}[c]{0.94\linewidth}
    \large \raggedright \sffamily \textbf{#1}
    \end{minipage}
}

\renewcommand\subsection[1]{
    \begin{minipage}[c]{0.94\linewidth}
    \raggedright \sffamily \textbf{#1}
    \end{minipage}
}

\newcommand\mycode[1]{{\small\texttt{#1}}}

\makeatletter

\title{An Inline Visitor Design Pattern for C++11}
\author{Robert W. Mill \and Jonathan B. Coe}

\begin{document}
\maketitle

Object-oriented programmers often wish to perform a function on an object of polymorphic type, such that the behaviour of the function is specific to the derived type. For instance, suppose we derive from the abstract base class \mycode{Polygon} the concrete classes \mycode{Triangle} and \mycode{Square}. Now suppose that we require a function \mycode{CountSides}, which returns the number of sides in the polygon, \mycode{p}.

{\small\begin{verbatim}
struct Polygon { };

struct Triangle : Polygon
{
  // members
}

struct Square : Polygon
{
  // members
}

int CountSides(Polygon& p);
{
  // implementation
}
\end{verbatim}}

Naturally, the algorithm used by \mycode{Angles} to compute its result depends on the derived type of \mycode{p}, which is problematic, because its argument is conveyed by a reference of the base class type, \mycode{Polygon}.

\section{Visitor pattern}

The \emph{visitor} design pattern offers a mechanism for switching to a code path specific to the derived type. The pattern uses the \mycode{this} pointer inside the class to identify the derived type. Each derived object must accept a visitor interface which provides a list of \mycode{Visit} members with single argument overloaded on various derived types.

To continue our illustration, the \mycode{PolygonVisitor} is able to `visit' \mycode{Triangle}s and \mycode{Square}s, and all these polygons must be able to `accept' an \mycode{PolygonVisitor}.

{\small\begin{verbatim}
struct Triangle;
struct Square;


struct PolygonVisitor
{
  virtual ~PolygonVisitor() {}

  virtual void Visit(Triangle& tr) = 0;
  virtual void Visit(Square& sq) = 0;
};

struct Polygon
{
  virtual void Accept(PolygonVisitor& v) = 0;
};
\end{verbatim}}

Squares and triangles accept the visitor as follows. Observe that the \mycode{this} pointer is used to select the appropriate overloaded function in the visitor interface.

{\small\begin{verbatim}
struct Triangle : Polygon
{
  void Accept(PolygonVisitor& v) override
  {
    v.Visit(*this);
  }
};

struct Square : Polygon
{
  void Accept(PolygonVisitor& v) override
  {
    v.Visit(*this);
  }
};
\end{verbatim}}

A visitor object, \mycode{SideCounter}, which counts the number of sides of a polygon and stores the result, is implemented and used as follows.

{\small\begin{verbatim}
struct SideCounter : PolygonVisitor
{
  void Visit(Square& sq) override
  {
    m_sides = 4;
  }
  
  void Visit(Triangle& tr) override
  {
    m_sides = 3;
  }
  
  int m_sides=0;
};

int CountSides(Polygon& p)
{
  SideCounter sideCounter;
  p.Accept(sideCounter);
  return sideCounter.m_sides;
}
\end{verbatim}}

\section{Inline visitor pattern}

One potential drawback of the visitor pattern is that it requires the creation 
of a new visitor object type for each algorithm that operates on the derived 
type. In some cases, the class created will not be reused and much like a 
lambda, it would be more convenient to write the visitor clauses inline, in a 
form that resembles a \mycode{switch} statement, as shown in the listing 
below. We omit \mycode{std::} for brevity.

{\small\begin{verbatim}
int CountSides(Polygon& p)
{
  int sides = 0;
  
  auto v =
    begin_visitor<PolygonVisitor>
    .on<Triangle>([&sides](Triangle& tr)
    {
      sides = 3;
    })
    .on<Square>([&sides](Square& sq)
    {
      sides = 4;
    })
    .end_visitor();
  
  p.Accept(v);
  return sides;
}
\end{verbatim}}

In what follows we demonstrate generic code that permits the \mycode{begin\_visitor} ... \mycode{end\_visitor} construction to be used with any visitor base. The principle behind the pattern is simple. The initial \mycode{start\_visitor} call returns an object which implements the visitor interface \emph{abstractly}; subsequent calls of the \mycode{on} function implement a \mycode{Visit} function which takes objects of the template argument type as an argument; and the \mycode{end\_visitor} call returns the \emph{concrete} visitor object.

\subsection{Listing 1}

{\small
\begin{verbatim}
template <typename T,
          typename F,
          typename BaseInner,
          typename ArgsT>
struct ComposeVisitor
{
  struct Inner : public BaseInner
  {
    using BaseInner::Visit;
  
    Inner(ArgsT&& args) :
      BaseInner(move(args.second)),
      m_f(move(args.first))
    {
    }
  
    void Visit(T& t) final override
    {
      m_f(t);
    }
  
  private:
    F m_f;
  };
  
  ComposeVisitor(ArgsT&& args) :
    m_args(move(args))
  {
  }
  

  template <typename Tadd,
            typename Fadd>
  ComposeVisitor<
    Tadd,
    Fadd,
    Inner,
    pair<Fadd, ArgsT>> on(Fadd&& f)
  {
    return ComposeVisitor
      Tadd,
      Fadd,
      Inner,
      pair<Fadd, ArgsT>>(
        make_pair(
          move(f),
          move(m_args)));
  }
  
  Inner end_visitor()
  {
    return Inner(move(m_args));
  }
  
  ArgsT m_args;
};

template <typename TVisitorBase>
struct EmptyVisitor
{
  struct Inner : public TVisitorBase
  {
    using TVisitorBase::Visit;
  
    Inner(nullptr_t) {}
  };
  
  template <typename Tadd, typename Fadd>
  ComposeVisitor<
    Tadd,
    Fadd,
    Inner,
    pair<Fadd, nullptr_t>> on(Fadd&& f)
  {
    return ComposeVisitor<
      Tadd,
      Fadd,
      Inner,
      pair<Fadd, nullptr_t>>(
        make_pair(
          move(f),
          nullptr));
  }
};

template <typename TVisitorBase>
EmptyVisitor<TVisitorBase> begin_visitor()
{
  return EmptyVisitor<TVisitorBase>();
}
\end{verbatim}}

The \mycode{start\_visitor<V>} function returns an object $t_0 = \mbox{\mycode{EmptyVisitor<V>}}$ which has the pure visitor interface \mycode{V} as a base class, but does not implement any \mycode{Visit} members.

Invoking \mycode{on<T1>} on a $t_0$ object returns an object which implements the \mycode{Visit(T1\&)} member that executes a function object with type \mycode{F1}. This object has type $t_1\, =$
{\small\begin{verbatim}
  ComposeVisitor<
    T1,
    F1,
    EmptyVisitor<T>,
    pair<F1,nullptr_t>>
\end{verbatim}}
which derives from $t_0$.

Invoking \mycode{on<T2>} on a $t_1$ object returns an object which implements the \mycode{Visit(T2\&)} member that executes a function object with type \mycode{F2}. This object has type $t_2\, =$
{\small\begin{verbatim}
  ComposeVisitor<
    T1,
    F,
    ComposeVisitor<
        T1,
        F,
        EmptyVisitor<T>,
        pair<F1,nullptr_t>>
    pair<F2,<pair<F1,nullptr_t>>
\end{verbatim}}
which derives from $t_1$, and so forth. These nested calls proceeds until a type is available which implements all the visitor members.

The pattern is complicated by the fact that no intermediate object returned in the nested series of calls to \mycode{on} is allowed to be abstract. As a solution, we construct the visitor type as an \emph{inner class}, and use \mycode{end\_visitor} to return an object of this inner class type at the end. If the \mycode{end\_visitor} function is invoked before the inner visitor class has concrete implementations for all \mycode{Visit} members, then the compiler will signal that the programmer has attempt to construct an object with an abstract type; otherwise a visitor is successfully returned.

A few advantages of this approach are notable compile-time [!!reword-jbc]. Firstly, because the \mycode{override} qualifier is included on the \mycode{Visit} member function, it is not possible to include a superfluous clause, which does not correspond to a type overload in the visitor base. Secondly, because the \mycode{final} qualifier is included on the \mycode{Visit} member function it is not possible to include a visit clause more than once. (If the \mycode{final} keyword were omitted, the most recent call to \mycode{on} would be observed for a given type.)

That inline visitors cannot be constructed when clauses are missing may also be considered desirable in some contexts. For instance, if a new type \mycode{Hexagon} is derived from \mycode{Polygon}, then the code base will compile only when appropriate code paths have been introduced to handle it. In large code bases, this may serve maintainability. If it is deemed that a visitor clause should have some default behaviour (e.g., no operation), a visitor base can be passed into \mycode{start\_visitor}.

\section{Performance considerations}

\end{document}

% end of file %
