\documentclass[10pt,a4paper,twocolumn]{article}

% Use packages
\usepackage{newcent}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mathrsfs}
\usepackage{color}

% Set lengths
\setlength{\parindent}{0pt}
\setlength{\parskip}{10pt}
\addtolength{\columnsep}{0.05in}
\addtolength{\textwidth}{1in}
\addtolength{\oddsidemargin}{-0.5in}
\addtolength{\topmargin}{-1in}
\addtolength{\textheight}{1.5in}

% Little hypenation, left aligned
\hyphenpenalty=1000
\raggedright

\makeatother

\renewcommand\section[1]{
%    \fcolorbox{white}{yellow}
%    {
    \begin{minipage}[c]{0.94\linewidth}
    \large \raggedright \sffamily \textbf{#1}
    \end{minipage}
%    }
}

\newcommand\mycode[1]{{\small\texttt{#1}}}

\makeatletter

\title{An Inline Visitor Design Pattern for C++11}
\author{Robert W. Mill \and Jonathan B. Coe}

\begin{document}
\maketitle

Object-oriented programmers often wish to perform a function on an object of polymorphic type, such that the behaviour of the function is specific to the derived type. For instance, suppose we derive from the abstract base class \mycode{Polygon} the concrete classes \mycode{Triangle} and \mycode{Square}. Now suppose that we require a function \mycode{CountSides}, which returns the number of sides in the polygon, \mycode{p}.

{\small\begin{verbatim}
struct Polygon { };

struct Triangle : Polygon
{
  // members
}

struct Square : Polygon
{
  // members
}

int CountSides(Polygon& p);
{
  // implementation
}
\end{verbatim}}

Naturally, the algorithm used by \mycode{Angles} to compute its result depends on the derived type of \mycode{p}, which is problematic, because its argument is conveyed by a reference of the base class type, \mycode{Polygon}.

\section{Visitor pattern}

The \emph{visitor} design pattern offers a mechanism for switching to a code path specific to the derived type. The pattern uses the \mycode{this} pointer inside the class to identify the derived type. Each derived object must accept a visitor interface which provides a list of \mycode{Visit} members with single argument overloaded on various derived types.

To continue our illustration, the \mycode{PolygonVisitor} is able to `visit' \mycode{Triangle}s and \mycode{Square}s, and all these polygons must be able to `accept' an \mycode{PolygonVisitor}.

{\small\begin{verbatim}
struct Triangle;
struct Square;

struct PolygonVisitor
{
  virtual ~PolygonVisitor() {}

  virtual void Visit(Triangle& tr) = 0;
  virtual void Visit(Square& sq) = 0;
};

struct Polygon : Polygon
{
  virtual void Accept(PolygonVisitor& v) = 0;
};
\end{verbatim}}

Squares and triangles accept the visitor as follows. Observe that the \mycode{this} pointer is used to select the appropriate overloaded function in the visitor interface.

{\small\begin{verbatim}
struct Triangle : Polygon
{
  void Accept(PolygonVisitor& v) override
  {
    v.Visit(*this);
  }
};

struct Square : Polygon
{
  void Accept(PolygonVisitor& v) override
  {
    v.Visit(*this);
  }
};
\end{verbatim}}

A visitor object, \mycode{SideCounter}, which counts the number of sides of a polygon and stores the result, is implemented and used as follows.

{\small\begin{verbatim}
struct SideCounter : PolygonVisitor
{
  void Visit(Square& sq) override
  {
    sides = 4;
  }
  
  void Visit(Triangle& tr) override
  {
    sides = 3;
  }
  
  int sides;
};

int CountSides(Polygon& p)
{
  SideCounter sideCounter;
  p.Accept(sideCounter);
  return sideCounter.sides;
}
\end{verbatim}}

\section{Inline visitor pattern}

{\small\begin{verbatim}
int CountSides(Polygon& p)
{
  int sides = 0;
  
  auto v =
    begin_visitor<PolygonVisitor>
    .on<Triangle>([&sides](Triangle& tr)
    {
      sides = 3;
    })
    .on<Square>([&sides](Square& sq)
    {
      sides = 4;
    })
    .end_visitor();
  
  p.Accept(v);
  return sides;
}
\end{verbatim}}

%{\small\begin{verbatim}
%template <typename T,
          %typename F,
          %typename B>
%class add_visitor : public B
%{
%public:
  %
  %add_visitor(F f) : m_f(std::move(f)) {}
  %
  %void Visit(T& t)
  %{
    %m_f(t);
  %}
  %
  %template<typename Tadd, typename Fadd>
  %void on(Fadd& fadd)
  %{
    %return add_visitor
      %<Tadd, Fadd, make_visitor<T,F,B>>
      %(std::move(fadd))
  %}
%
%private:
%
  %F m_f;
%};
%
%template <typename V>
%class make_visitor : public V
%{
%public:
  %
  %template<typename Tadd, typename Fadd>
  %void on(Fadd& fadd)
  %{
    %return add_visitor
      %<Tadd, Fadd, make_visitor<V>>
      %(std::move(fadd))
  %}
%};
%\end{verbatim}}

\newpage

{\small
\begin{verbatim}
template <typename T,
          typename F,
          typename BaseInnerVisitor,
          typename ArgsT>
class ComposeVisitor
{
public:
  class InnerVisitor : public BaseInnerVisitor
  {
  public:
    using BaseInnerVisitor::Visit;
  
    InnerVisitor(ArgsT&& args) :
      BaseInnerVisitor(std::move(args.second)),
      m_f(std::move(args.first))
    {
    }
  
    void Visit(T& t) final override
    {
      m_f(t);
    }
  
  private:
    F m_f;
  };
  
  ComposeVisitor(ArgsT&& args) :
    m_args(std::move(args))
  {
  }
  
  template <typename Tadd,
            typename Fadd>
  ComposeVisitor<
    Tadd,
    Fadd,
    InnerVisitor,
    std::pair<Fadd, ArgsT>> on(Fadd&& f)
  {
    return ComposeVisitor
      Tadd,
      Fadd,
      InnerVisitor,
      std::pair<Fadd, ArgsT>>(
        std::make_pair(
          std::move(f),
          std::move(m_args)));
  }
  
  InnerVisitor end_visitor()
  {
    return InnerVisitor(std::move(m_args));
  }
  
  ArgsT m_args;
};

template <typename TVisitorBase>
class EmptyVisitor
{
public:
  class InnerVisitor : public TVisitorBase
  {
  public:
    using TVisitorBase::Visit;
  
    InnerVisitor(std::nullptr_t) {}
  };
  
  template <typename Tadd, typename Fadd>
  ComposeVisitor<
    Tadd,
    Fadd,
    InnerVisitor,
    std::pair<Fadd, std::nullptr_t>> on(Fadd&& f)
  {
    return ComposeVisitor<
      Tadd,
      Fadd,
      InnerVisitor,
      std::pair<Fadd, std::nullptr_t>>(
        std::make_pair(
    	    std::move(f),
    	    nullptr));
  }
};

template <typename TVisitorBase>
EmptyVisitor<TVisitorBase> begin_visitor()
{
  return EmptyVisitor<TVisitorBase>();
}
\end{verbatim}}

\end{document}

% end of file %
