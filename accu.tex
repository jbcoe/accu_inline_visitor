\documentclass[10pt,a4paper,twocolumn]{article}

% Use packages
\usepackage{newcent}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mathrsfs}
\usepackage{color}

% Set lengths
\setlength{\parindent}{0pt}
\setlength{\parskip}{10pt}
\addtolength{\columnsep}{0.05in}
\addtolength{\textwidth}{1in}
\addtolength{\oddsidemargin}{-0.5in}
\addtolength{\topmargin}{-1in}
\addtolength{\textheight}{1.5in}

% Little hypenation, left aligned
\hyphenpenalty=1000
\raggedright

\makeatother

\renewcommand\section[1]{
    \begin{minipage}[c]{0.94\linewidth}
    \large \raggedright \sffamily \textbf{#1}
    \end{minipage}
}

\renewcommand\subsection[1]{
    \begin{minipage}[c]{0.94\linewidth}
    \raggedright \sffamily \textbf{#1}
    \end{minipage}
}

\newcommand\mycode[1]{{\small\texttt{#1}}}

\makeatletter

\title{An Inline Visitor Design Pattern for C++11}
\author{Robert W. Mill \and Jonathan B. Coe}

\begin{document}
\maketitle

Object-oriented programmers often wish to perform a function on an object of polymorphic type, such that the behaviour of the function is specific to the derived type. For instance, suppose we derive from the abstract base class \mycode{Polygon} the concrete classes \mycode{Triangle} and \mycode{Square}. Now suppose that we require a function \mycode{CountSides}, which returns the number of sides in the polygon, \mycode{p}.

{\small\begin{verbatim}
struct Polygon { };

struct Triangle : Polygon
{
  // members
}

struct Square : Polygon
{
  // members
}

int CountSides(Polygon& p);
{
  // implementation
}
\end{verbatim}}

Naturally, the algorithm used by \mycode{Angles} to compute its result depends on the derived type of \mycode{p}, which is problematic, because its argument is conveyed by a reference of the base class type, \mycode{Polygon}.

\section{Visitor pattern}

The \emph{visitor} design pattern offers a mechanism for switching to a code path specific to the derived type. The pattern uses the \mycode{this} pointer inside the class to identify the derived type. Each derived object must accept a visitor interface which provides a list of \mycode{Visit} members with single argument overloaded on various derived types.

To continue our illustration, the \mycode{PolygonVisitor} is able to `visit' \mycode{Triangle}s and \mycode{Square}s, and all these polygons must be able to `accept' an \mycode{PolygonVisitor}.

{\small\begin{verbatim}
struct Triangle;
struct Square;

struct PolygonVisitor
{
  virtual ~PolygonVisitor() {}

  virtual void Visit(Triangle& tr) = 0;
  virtual void Visit(Square& sq) = 0;
};

struct Polygon : Polygon
{
  virtual void Accept(PolygonVisitor& v) = 0;
};
\end{verbatim}}

Squares and triangles accept the visitor as follows. Observe that the \mycode{this} pointer is used to select the appropriate overloaded function in the visitor interface.

{\small\begin{verbatim}
struct Triangle : Polygon
{
  void Accept(PolygonVisitor& v) override
  {
    v.Visit(*this);
  }
};

struct Square : Polygon
{
  void Accept(PolygonVisitor& v) override
  {
    v.Visit(*this);
  }
};
\end{verbatim}}

A visitor object, \mycode{SideCounter}, which counts the number of sides of a polygon and stores the result, is implemented and used as follows.

{\small\begin{verbatim}
struct SideCounter : PolygonVisitor
{
  void Visit(Square& sq) override
  {
    sides = 4;
  }
  
  void Visit(Triangle& tr) override
  {
    sides = 3;
  }
  
  int sides;
};

int CountSides(Polygon& p)
{
  SideCounter sideCounter;
  p.Accept(sideCounter);
  return sideCounter.sides;
}
\end{verbatim}}

\section{Inline visitor pattern}

One potential drawback of the visitor pattern is that it requires the creation of a new visitor object type for each algoritm that operates on the derived type. In some cases, the creation of a dedicated class is excessive, and it would be more convenient to write the visitor clauses inline, in a form that resembles a \mycode{switch} statement, as shown in the listing below.

{\small\begin{verbatim}
int CountSides(Polygon& p)
{
  int sides = 0;
  
  auto v =
    begin_visitor<PolygonVisitor>
    .on<Triangle>([&sides](Triangle& tr)
    {
      sides = 3;
    })
    .on<Square>([&sides](Square& sq)
    {
      sides = 4;
    })
    .end_visitor();
  
  p.Accept(v);
  return sides;
}
\end{verbatim}}

In what follows we demonstrate generic code that permits the \mycode{begin\_visitor} ... \mycode{end\_visitor} construction to be used with any visitor base. The principle behind the pattern is simple. The initial \mycode{start\_visitor} call returns an object which implements the visitor interface \emph{abstractly}; subsequent calls of the \mycode{on} function implement a \mycode{Visit} function which takes objects of the template argument type as an argument; and the \mycode{end\_visitor} call returns the \emph{concrete} visitor object.

\subsection{Listing 1}

{\small
\begin{verbatim}
template <typename T,
          typename F,
          typename BaseInner,
          typename ArgsT>
class ComposeVisitor
{
public:
  class Inner : public BaseInner
  {
  public:
    using BaseInner::Visit;
  
    Inner(ArgsT&& args) :
      BaseInner(std::move(args.second)),
      m_f(std::move(args.first))
    {
    }
  
    void Visit(T& t) final override
    {
      m_f(t);
    }
  
  private:
    F m_f;
  };
  
  ComposeVisitor(ArgsT&& args) :
    m_args(std::move(args))
  {
  }
  
  template <typename Tadd,
            typename Fadd>
  ComposeVisitor<
    Tadd,
    Fadd,
    Inner,
    std::pair<Fadd, ArgsT>> on(Fadd&& f)
  {
    return ComposeVisitor
      Tadd,
      Fadd,
      Inner,
      std::pair<Fadd, ArgsT>>(
        std::make_pair(
          std::move(f),
          std::move(m_args)));
  }
  
  Inner end_visitor()
  {
    return Inner(std::move(m_args));
  }
  
  ArgsT m_args;
};

template <typename TVisitorBase>
class EmptyVisitor
{
public:
  class Inner : public TVisitorBase
  {
  public:
    using TVisitorBase::Visit;
  
    Inner(std::nullptr_t) {}
  };
  
  template <typename Tadd, typename Fadd>
  ComposeVisitor<
    Tadd,
    Fadd,
    Inner,
    std::pair<Fadd, std::nullptr_t>> on(Fadd&& f)
  {
    return ComposeVisitor<
      Tadd,
      Fadd,
      Inner,
      std::pair<Fadd, std::nullptr_t>>(
        std::make_pair(
          std::move(f),
          nullptr));
  }
};

template <typename TVisitorBase>
EmptyVisitor<TVisitorBase> begin_visitor()
{
  return EmptyVisitor<TVisitorBase>();
}
\end{verbatim}}

The \mycode{start\_visitor<V>} function returns an object $t_0 = \mbox{\mycode{EmptyVisitor<V>}}$ which has the pure visitor interface \mycode{V} as a base class, but does not implement any \mycode{Visit} members.

Invoking \mycode{on<T1>} on a $t_0$ object returns an object which implements the \mycode{Visit(T1\&)} member that executes a function object with type \mycode{F1}. This object has type $t_1\, =$
{\small\begin{verbatim}
  ComposeVisitor<
    T1,
    F1,
    EmptyVisitor<T>,
    pair<F1,nullptr_t>>
\end{verbatim}}
which derives from $t_0$. (We omit \mycode{std::} for brevity.)

Invoking \mycode{on<T2>} on a $t_1$ object returns an object which implements the \mycode{Visit(T2\&)} member that executes a function object with type \mycode{F2}. This object has type $t_2\, =$
{\small\begin{verbatim}
  ComposeVisitor<
    T1,
    F,
    ComposeVisitor<
        T1,
        F,
        EmptyVisitor<T>,
        pair<F1,nullptr_t>>
    pair<F2,<pair<F1,nullptr_t>>
\end{verbatim}}
which derives from $t_1$, and so forth. These nested calls proceeds until a type is available which implements all the visitor members.

The pattern is complicated by the fact that no intermediate object returned in the nested series of calls to \mycode{on} is allowed to be abstract. As a solution, we construct the visitor type as an \emph{inner class}, and use \mycode{end\_visitor} to return an object of this inner class type at the end. Inner class types are allowed remain abstract, provided they are never constructed. If the \mycode{end\_visitor} function is invoked before the inner visitor class has concrete implementations for all \mycode{Visit} members, then the compiler will signal that the programmer has attempt to construct an object with an abstract type; otherwise a visitor is successfully returned.

That inline visitors cannot be constructed when clauses are missing is desirable and fulfils one of the the original motivations for the visitor pattern. Two other advantages of this approach are notable compile-time. Firstly, because the \mycode{override} qualifier is included on the \mycode{Visit} member function, it is not possible to include a superfluous clause which does not correspond to a type overload in the visitor base. Secondly, because the \mycode{final} qualifier is included on the \mycode{Visit} member function it is not possible to include a visit clause more than once. (If the \mycode{final} keyword were omitted, the most recent call to \mycode{on} would be observed for a given type.)

\end{document}

% end of file %
